### CommonJS 规范

* 构成部分：
  模块应用（require）\ 模块定义（module.exports） \ 模块标识(即传递给require的参数)

### Node模块的实现

* node 引入模块的步骤：
  路径分析 -> 文件定位 -> 编译执行

* node模块分类：
  核心模块：node提供的（启动时直接被加载进内存中，文件定位和编译执行直接被省略。路径分析中优先判断，加载速度最快）
  文件模块：用户编写的（运行时动态加载）

* node 加载顺序（按照先后顺序）：
 （1）缓存优先：node会缓存编译和执行之后的文件对象。
 >在require二次加载时一律采用缓存优先策略，因为缓存加载不需要路径分析、文件定位和编译执行等过程，大大节约了时间，提高了效率。而这其中核心模块的缓存检查优于文件模块的检查
> 需要注意一下几点：
> * 文件名扩展分析： 当标志符中不带扩展名时，node会按照.js,.node,.json进行依次补足扩展名进行尝试查找。因为同时会调用fs模块进行同步式的阻塞式判断文件是否存在，因此会引起性能问题。优化方案是在node和json文件后面带上扩展名，会加快速度。同时配合缓存，能降低单线程中阻塞的影响。
> * 目录分析和包？？？？

（2）核心模块加载（node源代码编译过程中已经将它编译成二进制代码，所以它的加载过程很块。）
（3）路径形式的文件模块（以., .., ./等开头的路径标识符），require先将其转换为真实的文件路径，并以真实的路径进行文件查找，将编译后的二进制文件放到缓存中，使得二次加载更快。（其加载的速度比核心模块慢）
（4）自定义模块（类似npm包），它是查找最慢的方式。路径越深，查找越是耗时间。（参考模块路径的方式进行的查找）

> 模块路径：node在定位模块文件时制定的具体查找策略。表现为一个路径组成一个数组。它查找的方式有点类似于js的原型链查找。（1）先查找当前路径下的node_modules目录（2）查找父目录下node_modules（3）父目录的父目录的node_modules（4）。。。。。（5）直到查找到根目录下的node_modules目录。由此可见，路径越深耗时越多。
```
[ '/Users/weiweijiedetuhaomacji/node学习/node_modules',
  '/Users/weiweijiedetuhaomacji/node_modules',
  '/Users/node_modules',
  '/node_modules' ]
```

* 模块编译
编译和执行时引入模块的最后一阶段。
node会新建一个模块对象，然后根据路径载入并编译。而不同的文件扩展名，node调用的方法也不同（如下）。每个编译成功的文件，都会以它的文件路径为索引，存入Module._cache对象上，以提高二次引入的性能。
> .js文件，通过fs模块同步读取文件并编译。
  .node文件，用c/c++编写的文件，通过dlopen()方法加载最后编译生成的文件
  .json文件，通过fs模块同步读取文件后，用JSON.parse()解析返回的结果。
  .其余扩展文件，被当做.js文件载入。

值得注意的是，根据文件扩展名的不同，node不仅仅编译方式不同读取方式也不同。它使用Module._extenstion()(他会被赋值给require上面require.extensions)

(1) javascript 模块的编译 ？？？？
node对js对象进行了从头到尾的包装（详见书）
exports与module.exports的区别？？？
（2）c/c++模块的编译
.node模块文件不需要编译，因为它们是编写c/c++模块之后编译生成的文件。所以只需要加载和执行的过程。
（3）json文件的编译
它是三种方式中最简单的一种编译方式。